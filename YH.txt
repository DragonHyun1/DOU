스레드와 메인‑스레드만으로 테스트 자동화 도구를 구현할 때의 장·단점
(특히 Qt‑기반 UI + ADB / HVPM / DAQ 와 같은 I/O‑무거운 작업을 다루는 경우)

구분	설명	장점	단점 / 위험 요소
전체를 메인 스레드(UI 스레드)에서 수행	UI 이벤트 루프와 테스트 로직(ADB 명령, HVPM 설정, DAQ 수집, 파일 입출력 등)을 모두 같은 스레드에서 순차적으로 실행	* 구현이 가장 간단*
* 동기화 코드가 거의 필요 없음*	- UI가 완전히 차단 → 버튼 클릭, 윈도우 이동, 진동, 로그 화면 업데이트가 전혀 안 됨
- 긴 작업(예: 20 s 화면‑on/off 루프, DAQ 10 s 수집) 동안 응답 없음 → 사용자는 프로그램이 멈춘 것처럼 보임
- QBasicTimer / Qt 시그널이 백그라운드 스레드 없이 사용될 때만 안전하지만, time.sleep 로 인한 블로킹이 UI 전체에 전파됨
- 작업 중 중지/취소를 구현하기 어려워짐 (스레드가 차단된 상태라 stop_requested 를 체크해도 바로 반영되지 않음)
작업을 별도 워커 스레드(또는 스레드‑풀)로 이동	UI 스레드에서는 버튼·시그널·프로그레스 바만 관리하고, 시간·I/O‑무거운 로직은 QThread, QtConcurrent, concurrent.futures.ThreadPoolExecutor 등으로 실행	- UI 항상 반응 (버튼, 로그, 프로그레스 바가 실시간 업데이트)
- 취소·중단이 쉽게 구현 가능 (stop_requested 를 워커 스레드가 주기적으로 확인)
- 진행 상황을 pyqtSignal 로 UI에 전달 → QMetaObject.invokeMethod 로 큐에 넣어 스레드‑안전하게 전송 (Qt‑스레드‑안전 원칙을 지킴)
- 하드웨어·네트워크 I/O가 블로킹 되더라도 UI가 멈추지 않음 (ADB, DAQ, 파일 I/O 모두 비동기화 가능)
- 복수 시나리오(병렬 테스트, 멀티‑채널 모니터링 등)를 동시 실행하거나 비동기 파이프라인을 구성하기 쉬움	- 동기화 비용이 추가됨 (시그널·큐, Lock/Event 등)
- Qt 객체(예: QTimer, QPalette)는 메인 스레드에서만 접근해야 하므로, 워커 안에서 UI 객체를 건드리면 QBasicTimer 오류가 발생한다 (이미 겪은 문제). 따라서 UI와 데이터를 명확히 구분하고 신호 로만 교환해야 함.
- 파이썬 GIL(Global Interpreter Lock) 때문에 CPU‑bound 작업(복잡한 계산)에서는 실제 병렬화가 제한됨 → multiprocessing 혹은 C‑확장 필요. 하지만 테스트 자동화는 대부분 I/O‑bound(ADB, 네트워크, 파일)라 스레드만으로도 충분.
- 예외 전파가 복잡해질 수 있음 (워커에서 예외를 잡아 UI에 전달해야 함).
1️⃣ 왜 테스트 자동화 도구에 워커 스레드가 유리한가?
상황	워커‑스레드가 유리한 이유
장치 연결·명령 수행 (adb, hvpm, daq)	이들 명령은 시스템 콜 → 블로킹 I/O(수 초~수십 초) 가 많다. 워커 스레드에 맡기면 UI가 멈추지 않는다.
프로그레스/타이머 UI	QTimer 는 메인 스레드에서만 동작한다. 워커가 진행 상황을 progress_updated.emit(percent, msg) 로 보낼 때 QMetaObject.invokeMethod(..., QueuedConnection) 로 큐에 넣어야 한다. 메인 스레드는 이를 받아서 UI를 업데이트한다.
중단·취소	테스트 도중 stop_requested = True 로 플래그를 설정하고 워커가 while not stop_requested: … 로 주기적으로 체크하면 즉시 중단할 수 있다. 메인 스레드만 있으면 time.sleep 중에 플래그를 확인할 방법이 없으므로 거의 즉시 중단 불가.
다중 시나리오·동시 실행	예를 들어 Screen‑On/Off + Browser 테스트를 동시에 진행하고 싶을 때, 각각을 별도 스레드/작업 큐에 넣으면 실제 병렬 진행이 가능(하드웨어가 지원한다면).
로그·파일 I/O	테스트 결과를 실시간으로 파일/Excel 로 기록하는 작업이 I/O‑bound 이므로 워커에 두면 UI가 멈추지 않는다.
오류 격리	워커 안에서 발생한 예외는 try/except 로 잡아 UI 시그널(test_failed) 로 전파하면, 메인 루프가 그대로 살아 있다. 전체 프로그램이 다운되는 위험이 감소한다.
2️⃣ 구현 시 권장 구조 (Qt‑기반 파이썬)
Copy code
+------------------------+        +---------------------------+
|   Main (UI) Thread    | <----> |  Worker Thread (QThread)   |
| ── UI widgets          |  sig  | ── TestScenarioEngine      |
| ── Button callbacks    |       |     - long‑running steps   |
| ── progress_updated → |       |     - ADB / DAQ calls     |
|    (Queued)           |       |     - emit log, progress   |
+------------------------+        +---------------------------+
핵심 포인트
요소	구현 팁
시그널 전송	워커 스레드 안에서는 self._emit_signal_safe(self.progress_updated, percent, msg) 와 같이 큐드 연결 (Qt.ConnectionType.QueuedConnection) 을 사용한다. 직접 emit 하면 QBasicTimer 오류가 발생한다.
스레드 시작/종료	QThread 혹은 concurrent.futures.ThreadPoolExecutor 로 TestScenarioEngine.execute() 를 비동기로 실행한다. 종료 시 thread.join() 혹은 worker.quit(); worker.wait() 로 안전하게 정리한다.
취소 플래그	self.stop_requested = threading.Event() (또는 단순 bool) 를 워커와 UI가 공유하고, 워커 루프에서 if self.stop_requested.is_set(): break 로 체크. UI 버튼에서 engine.stop_requested.set() 로 플래그 전송.
예외 전달	워커 내부 try/except 로 잡은 예외를 self.test_completed.emit(False, str(e)) 로 UI에 전달하거나, 별도 error_occurred 시그널을 만든다.
데이터 공유	self.daq_data 와 같은 대용량 리스트는 읽기 전용으로 UI에 전달한다. UI가 수정해야 하면 copy.deepcopy 후 전달하거나, QStandardItemModel 로 변환한다.
리소스 정리	finally 블록에서 self.monitoring_active = False, self._screen_test_started.set(), self.monitoring_thread.join(timeout=5) 등을 수행해 쓰레드 누수를 방지한다.
CPU‑bound 작업	현재 대부분은 I/O‑bound 이므로 스레드만 충분. 필요 시 multiprocessing 으로 별도 프로세스에 넘겨도 된다(예: 대용량 데이터 분석).
테스트 프레임워크	pytest 로 워커 로직을 테스트할 때는 QT_AVAILABLE = False 로 강제하고, engine.start_test() 를 직접 호출해 동기식으로 실행한다(스레드 없이). 이렇게 하면 CI 환경에서도 쉽게 검증 가능.
3️⃣ 예시 – TestScenarioEngine 를 QThread 로 실행하기
python
Copy code
# main_window.py (버튼 클릭 시)
def on_start_test(self):
    # UI 버튼 비활성화, 진행 바 초기화 등
    self.ui.startBtn.setEnabled(False)

    # 엔진 객체 생성 (이미 메인 스레드에 있음)
    self.engine = TestScenarioEngine(
        hvpm_service=self.hvpm_service,
        daq_service=self.daq_service,
        log_callback=self._log_to_ui
    )

    # 워커 스레드 만들기
    self.worker = QtCore.QThread()
    self.engine.moveToThread(self.worker)

    # 시그널 연결 (UI <- 워커)
    self.engine.progress_updated.connect(self._on_progress)
    self.engine.test_completed.connect(self._on_test_finished)
    self.engine.log_message.connect(self._log_to_ui)

    # 워커 시작 시 엔진 실행
    self.worker.started.connect(lambda: self.engine.start_test("phone_app_test"))
    self.worker.start()

def on_stop_test(self):
    if self.engine:
        self.engine.stop_test()          # 플래그 설정
    if self.worker:
        self.worker.quit()               # 이벤트 루프 종료
        self.worker.wait(3000)           # 3초 안에 정리
핵심

engine 은 워커 스레드 안에서 동작한다.
UI는 engine.progress_updated 와 engine.log_message 를 Queued 로 받아 UI를 업데이트한다.
stop_test() 로 플래그를 세팅하면 워커 안의 루프가 바로 빠져나와 quit() 과 wait() 로 안전하게 스레드가 종료된다.
4️⃣ 스레드‑분리 vs. 단일‑스레드 (언제 단일 스레드가 괜찮은가?)
상황	단일‑스레드가 허용되는 경우
프로토타입 혹은 데모 – UI가 거의 없고, 직접 콘솔 로 진행 상황을 출력한다.	
짧은 자동화 (수 초 이하) – adb shell 명령이 0.5 ~ 2 초 정도만 걸릴 때.	
테스트 자동화가 아닌 배치 – GUI가 전혀 없고, 스크립트 로 순차 실행하는 경우.	
멀티‑플랫폼 UI 없이 – headless 환경(예: CI 파이프라인) 에서는 UI 스레드 개념이 없으므로 단일 스레드 로직이 자연스럽다.	
하지만 실제 현장 (디바이스 UI를 관찰·조작하고, 진행률 바와 로그를 실시간으로 보여 주어야 하는 경우) 에서는 워커 스레드 를 도입하는 것이 거의 필수다.

5️⃣ 요약 – 스레드‑분리가 테스트 자동화 도구에 주는 이점
이점	설명
UI 응답성	긴 작업 중에도 버튼·프로그레스 바가 동작, 사용자는 “멈춘” 느낌이 없음
취소·중단	stop_requested 플래그를 즉시 확인 → 작업을 빠르게 중단할 수 있음
진행 상황 전달	pyqtSignal 로 큐드 전송 → 메인 스레드가 안전하게 UI 업데이트
에러 격리	워커에서 발생한 예외가 UI를 붕괴시키지 않음, 오류 메시지만 UI에 전달
동시·병렬	여러 시나리오·채널을 동시에 모니터링하거나, UI와 별도로 백그라운드 로깅·데이터 수집이 가능
확장성	향후 멀티‑디바이스 테스트, 멀티‑채널 DAQ, 리포트 생성 등을 별도 스레드/프로세스로 쉽게 확장
테스트 코드	Qt 없이도 engine.start_test() 를 직접 호출해 로직을 유닛 테스트 할 수 있어 CI와 자동 검증이 쉬워짐
6️⃣ 실전 적용 체크리스트
스레드‑안전 시그널

모든 self.progress_updated.emit, self.log_message.emit, self.test_completed.emit 를 self._emit_signal_safe 로 감싸기.
self._emit_signal_safe 내부에 QMetaObject.invokeMethod(..., Qt.ConnectionType.QueuedConnection) 사용 확인.
워커 스레드 만들기

QThread 혹은 ThreadPoolExecutor 로 엔진 실행.
engine.moveToThread(worker) 로 객체를 워커에 바인딩.
취소 플래그

self.stop_requested = threading.Event() (or bool) 를 공유하고, 워커 루프에 if self.stop_requested.is_set(): break 삽입.
데이터 공유

self.daq_data 를 읽기 전용으로 UI에 전달하거나, 복사 후 전달.
UI 쪽에서 list(self.daq_data) 로 복제 후 사용.
에러 전파

워커 내부 except Exception as e: 로 로그 남기고 self.test_completed.emit(False, str(e)) 전송.
리소스 정리

워커 종료 시 self.monitoring_active = False
if self.monitoring_thread and self.monitoring_thread.is_alive(): self.monitoring_thread.join(timeout=5)
CI / 유닛 테스트

QT_AVAILABLE = False 로 강제하고, engine.start_test("screen_onoff") 를 직접 호출해 동기식 실행.
이렇게 하면 QTimer 등 UI 요소가 없어도 로직을 검증 가능.
7️⃣ 마무리
테스트 자동화는 I/O‑bound 작업이 핵심이므로 워커 스레드 도입만으로도 UI 응답성, 취소·중단, 오류 격리 등 대부분의 문제를 해결합니다.
Qt 와 Python 의 스레드 모델을 정확히 이해하고, 시그널‑큐 로 UI와 백그라운드를 연결하면 QBasicTimer 와 같은 오류 없이 안정적인 자동화 툴을 만들 수 있습니다.
위 권장 패턴을 적용하면 현재 코드베이스(TestScenarioEngine, ADBService 등)도 스레드‑안전하게 변환할 수 있습니다.
한 줄 정리
“UI 스레드가 차단되지 않도록 모든 장시간 I/O·대기 작업을 별도 워커 스레드(또는 풀)로 이동하고, Qt 시그널을 큐드 방식으로 UI에 전달하면 테스트 자동화 도구는 훨씬 견고하고 사용성 있게 된다.”
